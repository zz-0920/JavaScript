# node.js 基本架构

# node.js 是什么
是一个运行在操作系统上的 JavaScript 运行时环境，提供了一系列操作系统的 API，
可以使用 JavaScript 语言编写后端应用程序。

# 文章生成工具
- 输入标题
- 读取语料库
- 判断字数是否达标
- 是 -- 生成文章
- 否 -- 继续在语料库中选取内容


# HTTP 
- 标准的开放式互联网模型：
1. 物理层
2. 数据链路层
3. 网络层：IP 协议， DNS 解析
4. 传输层：TCP 协议
5. 会话层
6. 表示层
7. 应用层： HTTP 协议(超文本传输协议)

- 使用 net 模块创建 TCP 服务，用 TCP 服务来处理客户端的 HTTP 请求，需要使用字符串模板来组织 HTTP 请求和响应报文。

- 使用 http 模块创建 HTTP 服务，更简便处理 HTTP 请求和响应

- 为什么 http 服务要区分请求体和请求头。
  1. 为了内容协商 -- 客户端可以通过请求头来告诉服务器它支持的内容类型，服务器可以根据客户端的请求头来返回不同的内容类型。
  2. 为了请求的解析 -- HTTP 请求头和请求体是两个不同的部分，服务器需要先解析请求头，再解析请求体。

- 静态文件服务

- HTTP 缓存
 
- 强缓存 在响应头中添加 'Cache-Control': 'max-age=86400'

  - 浏览器会缓存文件，在缓存时间内，再次请求该文件，浏览器会直接从缓存中读取文件，不会向服务器请求文件。

  - 缓存时间可以通过 Cache-Control 头来设置，单位是秒。

  - 通过浏览器地址栏请求的资源是无法被强缓存的

- 协商缓存

  - 服务端返回一个资源并设置 'last-modified': stat.mtimeMs， 那么浏览器下一次请求该资源时，会自动在请求头中添加 'if-modified-since': 'last-modified' 的值，服务端会根据这个值来判断是否返回资源。

  - 协商缓存的缺陷：
    - 'last-modified': stat.mtimeMs 存在一个缺陷，就是如果资源改变又撤销改变，浏览器就因为资源最后一次修改时间对不上而重新获取资源

  - 解决办法：
    - 'etag': "文件指纹"： 每次资源改变，文件指纹就会改变，浏览器会根据文件指纹来判断是否返回资源。
    - 服务端返回资源时，会根据资源的内容计算出一个文件指纹，然后将文件指纹设置到响应头的 'etag' 中。
    - 浏览器下一次请求资源时，会自动在请求头中添加 'if-none-match': 'etag' 的值，服务端会根据这个值来判断是否返回资源。
    - 如果文件指纹没有改变，服务端会返回 304 状态码，浏览器会从缓存中读取文件。
    - 如果文件指纹改变，服务端会返回 200 状态码，浏览器会从服务器获取文件。

# 文件压缩
  - 
