# 1. js数组上常用的方法有哪些？
 - 增：push(), splice(), unshift(), concat()
 - 删：shift(), pop(), splice(), slice()
 - 改：splice(), flat()
 - 查：includes(), indexOf(), find(), findIndex(), lastIndexOf(), findLastIndex()
 - 迭代：forEach(), map(), filter(), sort(), reduce(), some(), ervey()

# 2. 聊一下 flat 方法
 - 是什么
  flat 是 Array 原型上的函数，用于将高维数组处理成低维数组

 - 原理：
  1. 递归
  2. reduce + 递归
  3. while + 解构
  4. toString()


# 3. 字符串上常见的方法有哪些
 - 增：concat()
 - 删：slice(), substring()
 - 改：replace(), toLowerCase(), toUpperCase(), trim(), trimStart(), trimEnd(), repeat(), padEnd(), padStart()
 - 查：indexOf()
 - split(), match()

# 4. 谈谈js 中的类型转换机制
 - 是什么
  js 引擎在执行各种运算符对于数据的类型是有要求的，如何数据类型和预期的不符合，就会发生类型转换

 - 特点：
  1. 显示类型转换
  2. 隐式类型转化
 
  - 显示类型转换：人为借助构造函数来将一种类型转换成希望的类型，这其中如果是原始值转原始值，官方给出了直接的转换结果。但如果是引用类型转原始类型：Number([1, 2])
   1. ToNumber([1, 2])  || ToString()
   2. ToPrimitive([1, 2], Number)
   3. 判断 参数 是否为原始类型，是则返回
   4. 否则，调用 xxx.valueOf()，得到原始值则返回
   5. 否则，调用 xxx.toString()，得到原始值则返回
   6. 否则报错

   <!-- String([1, 2]) -->

  - 隐式类型转化：通常发生在 四则运算（+ - * / %），比较运算（== != > < ）判断语句（if while）


# 5. 介绍一下 js 中的拷贝问题
 - 是什么
  因为js 中的原始类型存在栈中，引用类型存在堆中，再把引用地址存在栈中。所以拷贝通常只发生在引用类型上。效果是创建一份新的数据，让新数据拥有原数据一样的属性值

 - 方法 
  1. 浅拷贝：拷贝对象的属性，值如果是引用类型，则共用同一个地址
  2. 深拷贝：拷贝对象的属性，值如果是引用类型，则创建新的子对象来进行新的拷贝，实现层层拷贝

  - 浅拷贝: 
    slice(), 
    [].concat(arr), 
    [...arr], Object.create()
    arr.toReversed().reverse()
    Object.assign({}, obj)

  - 深拷贝：
   1. JSON.parse(JSON.stringify(obj))  --- 不能处理，undefined, function, symbol, 不能处理循环引用

   2. structuredClone()  --- 不能处理 function, symbol, bigint
   
   3. MessageChannel()  --- 不能处理 function, symbol

  
 - 原理
  深拷贝：递归拷贝，判断是否是引用类型，如果是则递归拷贝，否则直接赋值

# 6. 说说你对闭包的理解
 - 是什么
  根据作用域链的查找规则，内部函数一定有权力访问外部函数的变量。另外，一个函数执行完后它的执行上下文会被销毁。那么当函数A内部声明一个函数B,而函数B被拿到函数A外部执行时，为了保证以上两个规则正常执行，A函数在执行完毕后会将B需要访问的变量保存在一个集合当中，并留在调用栈当中，这个集合就是闭包。

 - 特点：
  1. 用于封装模块，避免全局变量污染
  2. 延长了变量的生命周期

  3. 造成内存泄露

 - 场景：
  1. 柯里化
  2. 单例模式

# 7. 说说你对 js 中作用域的理解
 - 是什么
  在一个区域中，生效了一些变量和函数，这种区域就叫作用域

 - 特点
  1. 全局作用域
  2. 函数作用域
  3. 块级作用域

  4. 词法作用域 -- 描述的是一个函数所处的作用域

 - 作用域链
  js 引擎在查找变量时，会现在当前作用域中查找，找不到就会去外层作用域查找，层层往上，直到全局作用域，这种查找的链状关系就叫作用域链

# 8. 说说你对 js 中原型的理解
 - 是什么
  在 js 中原型分为两种，一种是函数的原型（显示原型），一种是对象的原型（隐式原型），显示原型指的是函数身上自带的属性 prototype，隐式原型指的是对象上的 __proto__ 属性

 - 特点
  对象的 __proto__ 指向创建它的构造函数的 prototype，因为js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__ 上查找。所以原型存在的意义就是让实例对象可以访问到公共的方法

 - 原型链
  js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__ 上查找， 还找不到就会顺着 __proto__ 往上查找，直到找到 null 为止，这种查找关系就叫原型链

# 9. 说说 js 中的继承
 - 是什么
  让子类可以访问到父类的属性和方法

 - 实现方式
   1. 原型链继承 -- 多个实例共享一个原型对象，相互影响
   2. 构造函数继承  -- 无法继承到父类原型上的属性
   3. 组合继承  -- 父类构造函数会执行两次，浪费性能

   4. 原型式继承 -- 多个实例共享一个原型对象，相互影响
   5. 寄生式继承  -- 同上
   6. 寄生组合式继承  -- 最优解

   7. 类继承 -- 利用 extends 关键字实现继承

# 10. 说说你对 js 中 this 的理解
 - 是什么
  this 是 js 中的一个关键字，它可以简化上下文的参数传递，提高代码复用性，它的指向是由函数调用的方式决定的

 - 规则：
  1. 函数独立调用 --- 默认绑定规则 --- this 指向 window
  2. 函数被对象调用 --- 隐式绑定规则 --- this 指向该对象
  3. call, apply, bind  --- 显示绑定规则 --- this 指向绑定的对象
  4. 函数被 new 调用 --- 构造函数绑定规则 --- this 指向新创建的对象

# 11. 说说 js 中的事件流
 - 是什么
  js 中的事件流指的是事件在 DOM 中的传播顺序
  js 中的事件，用户在页面上面的交互操作，如点击事件，键盘敲击，鼠标移动等，这些事件会被浏览器捕获到，然后根据事件流的规则进行传播

 - 特点：
  1. 事件从 window 上往目标处传播  （捕获阶段）
  2. 事件在目标处触发  （目标阶段）
  3. 事件从目标处往 window 传播  （冒泡阶段）

 - 使用场景：
   借助事件冒泡机制，实现事件委托

# 12. js 中的类型判断有哪些方法
 1. typeof  只能判断除了 null 之外的原始类型 和 function
 2. instanceof   只能判断引用类型
 3. Array.isArray()
 4. Object.prototype.toString.call(xx)  -- 让xx 执行对象上的toString 方法

  - 对象上的toString --- 返回一个由 '[object' 和 内部属性 [[Class]] 的值和 ']' 组成的字符串
  - 数组上的toString --- 返回一个由数组元素组成的字符串，每个元素之间用逗号隔开
  - 其他类型上的toString --- 返回一个字符串字面量，如：'123'
  
# 13. 说说你对 js 事件循环的理解
 - 是什么
  因为js 默认是单线程运行的，所以在执行代码的过程中遇到耗时任务就会发生阻塞，为了解决这个问题，js 设计了一套循环执行同步和异步的机制，这个机制就是事件循环机制
  
 - 特点：
   - 同步任务：立即执行的任务
   - 异步任务：被挂起
     - 微任务：Promise.then, MutationObserver, process.nextTick(node.js)
     - 宏任务：script, setTimeout, setInterval, I/O, UI 渲染, postMessage, MessageChannel

     1. 先执行同步代码
     2. 执行微任务
     3. 有需要的话就进行渲染
     4. 执行宏任务 (第二次事件循环的开始)

# 14. 说说 js 中的防抖节流
 - 是什么
  是一种优化手段，比如搜索框的输入，scroll，click 等可能会在段时间内出发多次，非常浪费资源，防抖节流就是为了优化这种情况

 - 特点：
  1. 防抖：在规定的时间内，如果存在多次事件的触发，只执行最后一次
  2. 节流：在规定的时间内，只执行一次

 - 实现：
  1. 防抖: 
     将定时器存在闭包中，使全局可以访问同一个定时器。传入需要出发的回调函数和规定的时长。每次触发事件时，清除定时器，重新设置定时器。这样可以做到没有再触发事件后，定时器到期执行回调函数。
  2. 节流：
     将第一次的事件设置为0，每次触发事件时获得当前的时间并将其与上一次触发事件的时间进行对比。如果时间差大于规定的时间，则执行回调函数，并将当前时间设置为上一次触发事件的时间。


# 15. js 中的本地存储有哪些，区别是什么？
 1. cookies (这个空间中存放的内容 js 无法设置和修改，后端靠响应代码来存入)
   - 大小：4k
   - 过期时间：可以设置过期时间，不设置默认关闭浏览器就过期
   - 工作原理：浏览器会在每次请求时，将 cookies 中的内容添加到请求头中，后端可以通过请求头来获取 cookies 中的内容
   - 跨域：可以设置跨域

<!-- https://www.baidu.com/ -->
<!-- https://top.baidu.com/board -->

 2. localstorage
   - 大小：5M
   - 过期时间：不可以设置过期时间，默认永久存在
   - 工作原理：需要 js 手动存取
   - 跨域：不可以跨域

 3. sessionstorage
   - 大小：理论上无穷大
   - 过期时间：页面关闭就过期
   - 工作原理：需要 js 手动存取
   - 跨域：不可以跨域

 4. indexdb (纯客户端的本地数据库)
   - 大小：理论上无穷大
   - 过期时间：不可以设置过期时间，默认永久存在
   - 工作原理：需要 js 手动存取，支持存二进制
   - 跨域：不可以跨域
   - 适用场景：
     - 存储大量数据
     - 需要离线访问
