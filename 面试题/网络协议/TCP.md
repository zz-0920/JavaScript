# TCP 协议
1. 面向有连接
2. 可靠的
3. 有序的

- TCP头:
 1. Sequence Number 序列号
 2. Acknowledgment Number 确认号
 3. Data offset 数据偏移量
 4. Reserved 保留位
 5. Flags 标志符
  - SYN 同步标志位 1 (请求报文)
  - ACK 确认标志位 1 (确认报文)
  - PSH 推送标志位 1 (推送报文)
  - FIN 结束标志位 1 (结束报文)
  - RST 重置标志位 1 (重置报文)
  - URG 紧急标志位
 6. Window Size 窗口大小
 7. Checksum 校验和
 8. Urgent Pointer 紧急指针
 9. Options 选项

- 面向有连接 (三次握手)
 1. 客户端向服务端发送 SYN 包 请求建立连接 (客户端进入 SYN-SENT 状态 发送请求)
 2. 服务端收到 SYN 包后, 向客户端发送 SYN+ACK 包 确认连接 (服务端进入 SYN-RCVD 状态 等待确认)
 3. 客户端收到 SYN+ACK 包后, 向服务端发送 ACK 包 确认连接 (客户端进入 ESTABLISHED 状态, 服务端接收到 ACK 后也进入 ESTABLISHED 状态 建立连接状态)

- 考点: 为什么要三次握手才能建立连接, 两次行不行?
  - 两次握手: 客户端向服务端发送 SYN 包 请求建立连接, 服务端收到 SYN 包后, 向客户端发送 ACK 包 确认连接, 客户端收到 ACK 包后, 也进入 ESTABLISHED 状态 建立连接状态.
  - 三次握手: 客户端向服务端发送 SYN 包 请求建立连接, 服务端收到 SYN 包后, 向客户端发送 SYN+ACK 包 等待客户端确认, 客户端收到 SYN+ACK 包后, 向服务端发送 ACK 包 自己进入已连接状态, 服务端收到 ACK 包后, 也进入 ESTABLISHED 状态 建立连接状态.
  不行, 比如: 客服端向服务器发送建立连接请求A, 但因为外面刮风下雨等网络原因, 请求 A 超时未到达服务端, 那么 TCP 会启动重传机制, 再要求客户端发送一个新的建立连接请求B, 服务端成功收到请求 B 后, 再返回确认应答后进入连接状态, 之后传输完数据后释放连接. 此时, 假设那个请求A 历经千难万险终于来到了服务端, 服务端又误以为又有客户端要跟我建立连接, 那么服务端再返回确认应答进入连接状态, 但客户端其实是关闭状态, 这会导致服务端一直等待数据传输, 造成资源浪费 


- 可靠的 (超时重传机制, 拥塞控制)
 - 超时重传机制: 发送数据包之后, 超过一定时间后没有收到确认, 就会重新发送, 直到收到确认应答或者超过最大重试次数, 就会放弃发送, 这就是超时重传机制
 - 拥塞控制: TCP不知道网络是否可靠, 就会先发送少量的数据包测试一下环境, 如果收到了确认应答, 传输的数据包数量和速度逐步增加, 网络不好的时候, 又会逐步暂缓数据包的发送, 就像路上的开车一样, 公路宽的时候, 可以并行好几辆车, 窄的时候就只能单辆通过, 最终目的就是为了减少丢包


- 有序的 (每个包都有一个序号, 服务端会根据序号来排序)


- 四次挥手 (http 数据传输完毕后)
    1. 客户端向服务端发送一个 FIN 包, 请求关闭连接 (客户端进入 FIN-WAIT-1 状态 发送关闭请求)
    2. 服务端收到 FIN 包后, 向客户端发送一个 ACK 包, 确认关闭连接 (服务端进入 CLOSE-WAIT 状态 等待关闭)
    3. 服务端接着发送完未发送的数据后, 向客户端发送一个 FIN 包, 请求关闭连接 (服务端进入 LAST-ACK 状态 发送关闭请求)
    4. 客户端收到 FIN 包后, 向服务端发送一个 ACK 包, 确认关闭连接 (客户端进入 CLOSE 状态 关闭连接, 服务端也进入关闭状态)
        > 客户端发送完最后一个 ACK 包之后进入 TIME-WAIT 状态, 等待 2MSL 时间(两个数据包存活时间)后进入 CLOSE状态
